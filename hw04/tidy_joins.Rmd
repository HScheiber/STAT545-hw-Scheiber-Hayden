---
title: "Homework 4 - Tidy data and joins"
author: "Hayden Scheiber -"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  github_document
---

[Return to Main Page](https://github.com/HScheiber/STAT545-hw-Scheiber-Hayden/blob/master/README.md)

[Return to Homework 4 Landing Page](README.md)

---

- [General data reshaping and relationship to aggregation](#general-data-reshaping-and-relationship-to-aggregation)
    1. [Make a tibble with one row per year and columns for life expectancy for two or more countries](#make-a-tibble-with-one-row-per-year-and-columns-for-life-expectancy-for-two-or-more-countries)
    2. [Compute some measure of life expectancy for all possible combinations of continent and year](#compute-some-measure-of-life-expectancy-for-all-possible-combinations-of-continent-and-year)
    3. [Take a tibble with 24 rows: 2 per year, and reshape it so you have one row per year](#take-a-tibble-with-24-rows-2-per-year-and-reshape-it-so-you-have-one-row-per-year)

- [Join, merge, look up](#join-merge-look-up)
    1. [Create a second data frame, complementary to Gapminder. Join this with part of Gapminder](#create-a-second-data-frame-complementary-to-gapminder-join-this-with-part-of-gapminder)

---

Welcome! This is the data wrangling and reshaping skills development, as part of STAT 545 assignment 4.

First we need to load the `gapminder` dataset and the `tidyverse` package, as well as `knitr` for nicer table outputs. When making my plots I realized that I needed to re-shaped a data-frame using a function from `reshape2`, so I load that library as well.

```{r}
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(reshape2))
```

## General data reshaping and relationship to aggregation

### Make a tibble with one row per year and columns for life expectancy for two or more countries
<a href="#top">Back to top</a>

Let's compare life expectancy of _Canada_, _Rwanada_, and _China_. I begin by selecting data only from those countries using `filter`. Then, using `select` I retain only the columns I want to keep. I'll show the first 5 rows of this table to give an idea of what it looks like.

```{r}
data.selected.long <- gapminder %>%
        filter(country %in% c('Canada', 'Rwanda', 'China')) %>%
        select(country, year,lifeExp)

knitr::kable(head(data.selected.long,n=5))
```

Now it's time to reshape this data into the form we want. The `spread` function is used to convert a single column into multiple columns. This is useful for our _country_ column because there are only three values present there, which will become the three new columns in the reshaped dataframe.
```{r}
data.selected.wide <- data.selected.long %>%
        spread(country,lifeExp) 

knitr::kable(data.selected.wide,col.names = 
        c('Year','Life Expectancy in Canada (Years)', 
        'Life Expectancy in China (Years)', 
        'Life Expectancy in Rwanda (Years)'),
        align = 'c',
        caption = 'Based on data from Gapminder',
        format = 'markdown')
```

I found that it was easier to use the long format to make a scatterplot comparison of the selected country's life expectancies vs year.
```{r}
data.selected.long %>%
  ggplot(aes(x = year, y = lifeExp, colour=country)) + 
  geom_point() +
  scale_colour_discrete("Country") +
  scale_x_continuous(breaks = seq(1950, 2010, 10),
      labels = as.character(seq(1950, 2010, 10)),
      limits = c(1950, 2010),
      minor_breaks = NULL) +
  scale_y_continuous(breaks = seq(0, 85, 5),
      labels = as.character(seq(0, 85, 5)),
      limits = c(5, 85),
      minor_breaks = NULL) +
  theme_bw() + # black and white theme
  theme(axis.title = element_text(size=14),
      strip.text = element_text(size=14, face="bold"),
      plot.title = element_text(size=14, face="bold",hjust = 0.49),
      axis.text.x = element_text(size=12,face ="bold"),
      axis.text.y = element_text(size=12,face ="bold"),
      legend.title = element_text(size=14, face ="bold"),
      legend.text = element_text(size=12, face ="bold")) +
  labs(x = "Year", 
      y = "Life Expectancy",
      title = "Comparison of Life Expectancies: Canada, Rwanada, and China",
      caption = "Based on data from Gapminder")
```

### Compute some measure of life expectancy for all possible combinations of continent and year
<a href="#top">Back to top</a>

In this section, I have decided that I will compute the median life expectancy for each continent at each year.
```{r,fig.width=8}
data.lifeExp.wide <- gapminder %>%
        group_by(continent, year) %>%
        mutate(lifeExp.median = median(lifeExp)) %>%
        select(continent, year, lifeExp.median) %>%
        unique() %>%
        spread(continent,lifeExp.median)

knitr::kable(data.lifeExp.wide,col.names = 
        c('Year','Africa', 
        'Americas', 
        'Asia', 
        'Europe', 
        'Oceania'),
        align = 'c',
        format = 'html', 
        caption = "<h4>Median Life Expectancy by Continent (Years)</h4>")

```
To exchange columns for rows is very easy in R. Just use the transpose function `t()`.

```{r}
data.lifeExp.wide.t <- t(data.lifeExp.wide)
  
# This step forces the years to be formatted as integers instead of floating point numbers
data.lifeExp.wide.t.table <- rbind(formatC(data.lifeExp.wide.t[1,],format="d"),
        data.lifeExp.wide.t[-1,])

knitr::kable(data.lifeExp.wide.t.table, 
        col.names = NULL,
        align = 'c',
        format = 'html', 
        caption = "<h4>Median Life Expectancy by Continent (Years)</h4>")
```

This type of data format is human readable, but it isn't the best format for `ggplot`. The only types of plots I could *maybe* see being easier with these formats are comparisons between different years or different continents. Even then, it seems to make colouring points by continent more awkward.
```{r,fig.width=8}
ggplot(data.lifeExp.wide,aes(x = year)) +
  geom_point(aes(y=Europe, colour='Europe')) +
  geom_point(aes(y=Asia, colour='Asia')) +
  scale_x_continuous(breaks = seq(1950, 2010, 10),
    labels = as.character(seq(1950, 2010, 10)),
    limits = c(1950, 2010),
    minor_breaks = NULL) +
  scale_colour_discrete(name = "Continent") +
  theme_minimal() +
  theme(axis.text.x = element_text(size=12,face ="bold"),
    axis.text.y = element_text(size=12,face ="bold"),
    plot.title = element_text(size=16,face ="bold",hjust = 0.5),
    axis.title = element_text(size=14, face ="bold"),
    legend.title = element_text(size=14, face ="bold"),
    legend.text = element_text(size=12, face ="bold")) +
  labs(x = "Year", 
    y = "Median Life Expectancy (Year)",
    title = "Comparison of Median Life Expectancy by Year: Asia vs Europe",
    caption = "Based on data from Gapminder")
```

If we use data in long format, as below, only a single layer of `geom_point` is required, but I also have to `filter` the data first. I think this method is better simply because of the colour aesthetic, which automatically maps to continent. In the previous example I had to manually map it, which just felt wrong.
```{r,fig.width=8}
# Same process as before, but without spread
data.lifeExp.long <- gapminder %>%
  group_by(continent, year) %>%
  mutate(lifeExp.median = median(lifeExp)) %>%
  select(continent, year, lifeExp.median) %>%
  unique()

data.lifeExp.long %>%
  filter(continent %in% c('Americas','Africa')) %>%
  ggplot(aes(x = year, y = lifeExp.median, colour = continent)) +
  geom_point() +
  scale_x_continuous(breaks = seq(1950, 2010, 10),
    labels = as.character(seq(1950, 2010, 10)),
    limits = c(1950, 2010),
    minor_breaks = NULL) +
  scale_colour_discrete(name = "Continent") +
  theme_minimal() +
  theme(axis.text.x = element_text(size=12,face ="bold"),
    axis.text.y = element_text(size=12,face ="bold"),
    plot.title = element_text(size=16,face ="bold",hjust = 0.5),
    axis.title = element_text(size=14, face ="bold"),
    legend.title = element_text(size=14, face ="bold"),
    legend.text = element_text(size=12, face ="bold")) +
  labs(x = "Year", 
    y = "Median Life Expectancy (Year)",
    title = "Comparison of Median Life Expectancy by Year: Americas vs Africa",
    caption = "Based on data from Gapminder")
```

### Take a tibble with 24 rows: 2 per year, and reshape it so you have one row per year
<a href="#top">Back to top</a>

For this, we start with the tibble created [here](http://stat545.com/block010_dplyr-end-single-table.html#window-functions "Window Functions").
```{r}
data.lifeExp.Asia <- gapminder %>%
  filter(continent == "Asia") %>%
  select(year, country, lifeExp) %>%
  group_by(year) %>%
  filter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2) %>% 
  arrange(year)

knitr::kable(data.lifeExp.Asia, 
  col.names = c('Year','Country','Life Expectancy (Years)'),
  align = 'c',
  format = 'html', 
  caption = "<h4>Highest and Lowest Life Expectancy by Year in Asia</h4>")
```

I would like to reshape this data so that there is only one row per year. I think there is probably an easier way of doing this, but I found a way that worked! I added new columns that indicated the maximum and minimum life expectancy of each year group, then cut away the previous and removed the duplicates.
```{r}
data.lifeExp.Asia.grouped <- data.lifeExp.Asia %>%
  group_by(year) %>%
  mutate(min.lifeExp = min(lifeExp), 
         max.lifeExp = max(lifeExp),
         min.lifeExp.Country = country[1], 
         max.lifeExp.Country = country[2]) %>%
  select(year, 
         min.lifeExp.Country,
         min.lifeExp,
         max.lifeExp.Country,
         max.lifeExp) %>%
  unique()

knitr::kable(data.lifeExp.Asia.grouped,
  col.names = c("Year", 
                "Country with Lowest Life Expectancy",
                "Life Expectancy (Years)",
                "Country with Highest Life Expectancy",
                "Life Expectancy (Years)"),
  align = 'c',
  format = 'html', 
  caption = "<h4>Highest and Lowest Life Expectancy by Year in Asia (Years)</h4>")
```

## Join, merge, look up

### Create a second data frame, complementary to Gapminder. Join this with part of Gapminder
<a href="#top">Back to top</a>

Hello.